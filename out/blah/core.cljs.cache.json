["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$blah.core","~:imports",null,"~:requires",["^ ","~$impl","~$blah.impl","^:","^:","~$blah.spec","^;","~$s","~$cljs.spec.alpha","^<","^<"],"~:cljs.spec/speced-vars",["~$blah.core/input-ch","~$blah.core/audio-context","~$blah.core/input","~$blah.core/query-inputs"],"~:uses",null,"~:defs",["^ ","~$query-inputs",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/brian/projects/blah/src/blah/core.cljs","~:line",13,"~:column",7,"~:end-line",13,"~:end-column",19,"~:arglists",["~#list",["~$quote",["^M",[["~$fn-1"]]]]],"~:doc","Query for audio inputs. Calls fn-1 with a sequence\n   of inputs."],"^5","^A","^G","/Users/brian/projects/blah/src/blah/core.cljs","^K",19,"~:method-params",["^M",[["^O"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^I",1,"~:variadic?",false,"^H",13,"~:ret-tag","~$js/RESULT","^J",13,"~:max-fixed-arity",1,"~:fn-var",true,"^L",["^M",["^N",["^M",[["^O"]]]]],"^P","Query for audio inputs. Calls fn-1 with a sequence\n   of inputs."],"~$input-ch",["^ ","^E",null,"^F",["^ ","^G","/Users/brian/projects/blah/src/blah/core.cljs","^H",23,"^I",7,"^J",23,"^K",15,"^L",["^M",["^N",["^M",[["~$close-ch"],[]]]]],"^P","Returns a channel that receives a sequence of inputs whenever there\n   is a change to the list of available inputs, an example being the user\n   connects or disconnects a microphone.\n   \n   Creating an input-ch will place an initial sequence of inputs on the channel before\n   it is returned.\n   \n   A close channel is not required, but is necessary to gracefully shut down the input channel. This\n   is mostly to unbind event listeners bound to the global mediaDevices object. If the input channel is not\n   gracefully shut down, the result may be extra messages to your input-ch. There are worse fates\n   in life.\n   \n   ```clojure\n   (let [inputs (input-ch)]\n     (go-loop []\n       (let [audio-inputs (<! inputs)]\n         (update-ui audio-inputs))))\n   ```","~:top-fn",["^ ","^T",false,"~:fixed-arity",1,"^W",1,"^Q",[["^Z"],[]],"^L",["^M",[["^Z"],[]]],"^S",["^M",[null,null]]]],"^5","^>","^G","/Users/brian/projects/blah/src/blah/core.cljs","^K",15,"^[",["^ ","^T",false,"^10",1,"^W",1,"^Q",[["^Z"],[]],"^L",["^M",[["^Z"],[]]],"^S",["^M",[null,null]]],"^Q",[["^Z"],[]],"^R",null,"^10",1,"^S",["^M",[null,null]],"^I",1,"^T",false,"~:methods",[["^ ","^10",1,"^T",false,"~:tag","~$any"],["^ ","^10",0,"^T",false,"^12","^13"]],"^H",23,"^J",23,"^W",1,"^X",true,"^L",["^M",[["^Z"],[]]],"^P","Returns a channel that receives a sequence of inputs whenever there\n   is a change to the list of available inputs, an example being the user\n   connects or disconnects a microphone.\n   \n   Creating an input-ch will place an initial sequence of inputs on the channel before\n   it is returned.\n   \n   A close channel is not required, but is necessary to gracefully shut down the input channel. This\n   is mostly to unbind event listeners bound to the global mediaDevices object. If the input channel is not\n   gracefully shut down, the result may be extra messages to your input-ch. There are worse fates\n   in life.\n   \n   ```clojure\n   (let [inputs (input-ch)]\n     (go-loop []\n       (let [audio-inputs (<! inputs)]\n         (update-ui audio-inputs))))\n   ```"],"~$audio-context",["^ ","^E",null,"^F",["^ ","^G","/Users/brian/projects/blah/src/blah/core.cljs","^H",51,"^I",7,"^J",51,"^K",20,"^L",["^M",["^N",["^M",[["~$session"]]]]],"^P","Returns a session's underlying AudioContext object.\n   \n   This function provides a useful convenience.\n   \n   Many browsers prevent interaction with AudioContext until a user action\n   initiates them - i.e a user must click a button before a sound is played or\n   access to a mic is granted.\n   \n   This function allows access to an AudioContext object that is already \"warm\" after\n   being created as part of starting a blah session via the [[listen]] function.\n   \n   A typical use case might be wanting to play some audio back to a user after recording them."],"^5","^?","^G","/Users/brian/projects/blah/src/blah/core.cljs","^K",20,"^Q",["^M",[["^15"]]],"^R",null,"^S",["^M",[null,null]],"^I",1,"^T",false,"^H",51,"^U","^13","^J",51,"^W",1,"^X",true,"^L",["^M",["^N",["^M",[["^15"]]]]],"^P","Returns a session's underlying AudioContext object.\n   \n   This function provides a useful convenience.\n   \n   Many browsers prevent interaction with AudioContext until a user action\n   initiates them - i.e a user must click a button before a sound is played or\n   access to a mic is granted.\n   \n   This function allows access to an AudioContext object that is already \"warm\" after\n   being created as part of starting a blah session via the [[listen]] function.\n   \n   A typical use case might be wanting to play some audio back to a user after recording them."],"~$listen",["^ ","^E",null,"^F",["^ ","^G","/Users/brian/projects/blah/src/blah/core.cljs","^H",71,"^I",7,"^J",71,"^K",13,"^L",["^M",["^N",["^M",[["~$input","~$xform","~$ex-handler"],["^17","^18"],["^17"],[]]]]],"^P","Initiates a blah session.\n   \n   A blah session is a core.async ReadPort that is composed of, and provides access to, an AudioContext.\n   \n   Being a ReadPort, it is consumed like any other core.async channel.\n   \n   The buffer size of the channel is determined by the AudioContext's sample rate. The signature for this\n   function is identical to core.async/chan expect an input is accepted in place of buf-or-n. A nil input\n   can be supplied in order to leverage the default audio input.\n   \n   Can be given an optional transducer to process incoming audio data, and an optional exception-handler.\n   If an exception occurs during transformation exception-handler will be called with the error, and any\n   non-nil return value will be placed in the channel.\n   \n   If no transducer is given, a default will be provided via [[blah.transforms/samples->frames]]. This transform\n   will return streamed data as a sequence of partitioned sample frames - i.e:\n\n   ```clojure\n   ((input-channel-1-sample-1\n     input-channel-2-sample-1)\n   \n    (input-channel-1-sample-2\n     input-channel-2-sample-2))\n   ```\n   \n   The channels raw data format is a js array containing Float32 array for each audio input channel:\n   \n   ```clojure\n   (defn samples->frames\n     [message] ;;; message = #js [floats-for-input-channel-1, floats-for-input-channel-2, ..., floats-for-input-channel-n]\n     (process-message))\n   ```","^[",["^ ","^T",false,"^10",3,"^W",3,"^Q",[["^17","^18","^19"],["^17","^18"],["^17"],[]],"^L",["^M",[["^17","^18","^19"],["^17","^18"],["^17"],[]]],"^S",["^M",[null,null,null,null]]]],"^5","~$blah.core/listen","^G","/Users/brian/projects/blah/src/blah/core.cljs","^K",13,"^[",["^ ","^T",false,"^10",3,"^W",3,"^Q",[["^17","^18","^19"],["^17","^18"],["^17"],[]],"^L",["^M",[["^17","^18","^19"],["^17","^18"],["^17"],[]]],"^S",["^M",[null,null,null,null]]],"^Q",[["^17","^18","^19"],["^17","^18"],["^17"],[]],"^R",null,"^10",3,"^S",["^M",[null,null,null,null]],"^I",1,"^T",false,"^11",[["^ ","^10",3,"^T",false,"^12","~$blah.impl/Session"],["^ ","^10",2,"^T",false,"^12","^1;"],["^ ","^10",1,"^T",false,"^12","^1;"],["^ ","^10",0,"^T",false,"^12","^1;"]],"^H",71,"^J",71,"^W",3,"^X",true,"^L",["^M",[["^17","^18","^19"],["^17","^18"],["^17"],[]]],"^P","Initiates a blah session.\n   \n   A blah session is a core.async ReadPort that is composed of, and provides access to, an AudioContext.\n   \n   Being a ReadPort, it is consumed like any other core.async channel.\n   \n   The buffer size of the channel is determined by the AudioContext's sample rate. The signature for this\n   function is identical to core.async/chan expect an input is accepted in place of buf-or-n. A nil input\n   can be supplied in order to leverage the default audio input.\n   \n   Can be given an optional transducer to process incoming audio data, and an optional exception-handler.\n   If an exception occurs during transformation exception-handler will be called with the error, and any\n   non-nil return value will be placed in the channel.\n   \n   If no transducer is given, a default will be provided via [[blah.transforms/samples->frames]]. This transform\n   will return streamed data as a sequence of partitioned sample frames - i.e:\n\n   ```clojure\n   ((input-channel-1-sample-1\n     input-channel-2-sample-1)\n   \n    (input-channel-1-sample-2\n     input-channel-2-sample-2))\n   ```\n   \n   The channels raw data format is a js array containing Float32 array for each audio input channel:\n   \n   ```clojure\n   (defn samples->frames\n     [message] ;;; message = #js [floats-for-input-channel-1, floats-for-input-channel-2, ..., floats-for-input-channel-n]\n     (process-message))\n   ```"]],"~:cljs.spec/registry-ref",[["^>",["^M",["~$cljs.spec.alpha/fspec","~:args",["^M",["~$cljs.spec.alpha/cat","~:close-ch",["^M",["~$cljs.spec.alpha/?","~:blah.spec/write-port"]]]],"~:ret","~:blah.spec/read-port"]]],["^?",["^M",["^1=","^1>",["^M",["^1?","~:session","~:blah.spec/session"]],"^1C","~:blah.spec/audio-context"]]],["^@",["^M",["^1=","^1>",["^M",["~$cljs.spec.alpha/alt","~:null",["^M",["^1?"]],"~:unary",["^M",["^1?","~:input",["^M",["~$cljs.spec.alpha/nilable","~:blah.spec/input"]]]],"~:binary",["^M",["^1?","^1K",["^M",["^1L","^1M"]],"~:xform","~$cljs.core/any?"]],"~:all",["^M",["^1?","^1K",["^M",["^1L","^1M"]],"^1O","^1P","~:ex-handler","~$cljs.core/fn?"]]]],"^1C","^1F"]]],["^A",["^M",["^1=","^1>",["^M",["^1?","~:fn-1","~:blah.spec/query-input-handler"]],"^1C","^1P"]]]],"~:require-macros",["^ ","~$s","^<","^<","^<"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^1>","^1O","^1N","^>","^1C","^1G","^1H","^1D","^1@","^1?","^1=","^1L","^?","^1Q","^1U","^1R","^1S","^1M","^1I","^1F","^1J","^1K","^1B","^@","^1P","^A","^1T","^1E","^1A"]],"~:order",["^A","^1=","^1>","^1?","^1T","^1U","^1C","^1P","^>","^1@","^1A","^1B","^1D","^?","^1E","^1F","^1G","^@","^1H","^1I","^1J","^1K","^1L","^1M","^1N","^1O","^1Q","^1R","^1S"]],"^P","Work with audio inputs the Clojure(Script) way.\n   \n   blah aims to be a simple utility for gathering audio input\n   as a stream of data.\n   \n   blah's main purpose is to produce a cljs.core.async channel\n   of audio data (presumably from a user's microphone)."]