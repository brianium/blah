["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$blah.core","~:imports",null,"~:requires",["^ ","~$impl","~$blah.impl","^:","^:","~$blah.spec","^;","~$s","~$cljs.spec.alpha","^<","^<"],"~:cljs.spec/speced-vars",["~$blah.core/input-ch","~$blah.core/listen","~$blah.core/audio-context","~$blah.core/request-permission","~$blah.core/query-inputs"],"~:uses",null,"~:defs",["^ ","~$query-inputs",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/brian/projects/blah/src/blah/core.cljs","~:line",13,"~:column",7,"~:end-line",13,"~:end-column",19,"~:arglists",["~#list",["~$quote",["^N",[["~$fn-1"]]]]],"~:doc","Query for audio inputs. Calls fn-1 with a sequence\n   of inputs."],"^5","^B","^H","/Users/brian/projects/blah/src/blah/core.cljs","^L",19,"~:method-params",["^N",[["^P"]]],"~:protocol-impl",null,"~:arglists-meta",["^N",[null,null]],"^J",1,"~:variadic?",false,"^I",13,"~:ret-tag","~$js/RESULT","^K",13,"~:max-fixed-arity",1,"~:fn-var",true,"^M",["^N",["^O",["^N",[["^P"]]]]],"^Q","Query for audio inputs. Calls fn-1 with a sequence\n   of inputs."],"~$input-ch",["^ ","^F",null,"^G",["^ ","^H","/Users/brian/projects/blah/src/blah/core.cljs","^I",23,"^J",7,"^K",23,"^L",15,"^M",["^N",["^O",["^N",[[]]]]],"^Q","Returns a channel that receives a sequence of inputs whenever there\n   is a change to the list of available inputs, an example being the user\n   connects or disconnects a microphone.\n   \n   Creating an input-ch will place an initial sequence of inputs on the channel before\n   it is returned.\n   \n   This channel should be closed when it is no longer needed. This is mostly to unbind event listeners\n   bound to the global mediaDevices object.\n   \n   ```clojure\n   (let [inputs (input-ch)]\n     (go-loop []\n       (let [audio-inputs (<! inputs)]\n         (update-ui audio-inputs))))\n   ```"],"^5","^>","^H","/Users/brian/projects/blah/src/blah/core.cljs","^L",15,"^R",["^N",[[]]],"^S",null,"^T",["^N",[null,null]],"^J",1,"^U",false,"^I",23,"^V","~$any","^K",23,"^X",0,"^Y",true,"^M",["^N",["^O",["^N",[[]]]]],"^Q","Returns a channel that receives a sequence of inputs whenever there\n   is a change to the list of available inputs, an example being the user\n   connects or disconnects a microphone.\n   \n   Creating an input-ch will place an initial sequence of inputs on the channel before\n   it is returned.\n   \n   This channel should be closed when it is no longer needed. This is mostly to unbind event listeners\n   bound to the global mediaDevices object.\n   \n   ```clojure\n   (let [inputs (input-ch)]\n     (go-loop []\n       (let [audio-inputs (<! inputs)]\n         (update-ui audio-inputs))))\n   ```"],"~$audio-context",["^ ","^F",null,"^G",["^ ","^H","/Users/brian/projects/blah/src/blah/core.cljs","^I",47,"^J",7,"^K",47,"^L",20,"^M",["^N",["^O",["^N",[["~$session"]]]]],"^Q","Returns a session's underlying AudioContext object.\n   \n   This function provides a useful convenience.\n   \n   Many browsers prevent interaction with AudioContext until a user action\n   initiates them - i.e a user must click a button before a sound is played or\n   access to a mic is granted.\n   \n   This function allows access to an AudioContext object that is already \"warm\" after\n   being created as part of starting a blah session via the [[listen]] function.\n   \n   A typical use case might be wanting to play some audio back to a user after recording them."],"^5","^@","^H","/Users/brian/projects/blah/src/blah/core.cljs","^L",20,"^R",["^N",[["^11"]]],"^S",null,"^T",["^N",[null,null]],"^J",1,"^U",false,"^I",47,"^V","^[","^K",47,"^X",1,"^Y",true,"^M",["^N",["^O",["^N",[["^11"]]]]],"^Q","Returns a session's underlying AudioContext object.\n   \n   This function provides a useful convenience.\n   \n   Many browsers prevent interaction with AudioContext until a user action\n   initiates them - i.e a user must click a button before a sound is played or\n   access to a mic is granted.\n   \n   This function allows access to an AudioContext object that is already \"warm\" after\n   being created as part of starting a blah session via the [[listen]] function.\n   \n   A typical use case might be wanting to play some audio back to a user after recording them."],"~$listen",["^ ","^F",null,"^G",["^ ","^H","/Users/brian/projects/blah/src/blah/core.cljs","^I",67,"^J",7,"^K",67,"^L",13,"^M",["^N",["^O",["^N",[["~$input","~$xform","~$ex-handler"],["^13","^14"],["^13"],[]]]]],"^Q","Initiates a blah session.\n   \n   A blah session is a core.async ReadPort that is composed of, and provides access to, an AudioContext.\n   \n   Being a ReadPort, it is consumed like any other core.async channel.\n   \n   The buffer size of the channel is determined by the AudioContext's sample rate. The signature for this\n   function is identical to core.async/chan expect an input is accepted in place of buf-or-n. A nil input\n   can be supplied in order to leverage the default audio input.\n   \n   Can be given an optional transducer to process incoming audio data, and an optional exception-handler.\n   If an exception occurs during transformation exception-handler will be called with the error, and any\n   non-nil return value will be placed in the channel.\n   \n   If no transducer is given, a default will be provided via [[blah.transforms/samples->frames]]. This transform\n   will return streamed data as a sequence of partitioned sample frames - i.e:\n\n   ```clojure\n   ((input-channel-1-sample-1\n     input-channel-2-sample-1)\n   \n    (input-channel-1-sample-2\n     input-channel-2-sample-2))\n   ```\n   \n   The channels raw data format is a js array containing Float32 array for each audio input channel:\n   \n   ```clojure\n   (defn samples->frames\n     [message] ;;; message = #js [floats-for-input-channel-1, floats-for-input-channel-2, ..., floats-for-input-channel-n]\n     (process-message))\n   ```","~:top-fn",["^ ","^U",false,"~:fixed-arity",3,"^X",3,"^R",[["^13","^14","^15"],["^13","^14"],["^13"],[]],"^M",["^N",[["^13","^14","^15"],["^13","^14"],["^13"],[]]],"^T",["^N",[null,null,null,null]]]],"^5","^?","^H","/Users/brian/projects/blah/src/blah/core.cljs","^L",13,"^16",["^ ","^U",false,"^17",3,"^X",3,"^R",[["^13","^14","^15"],["^13","^14"],["^13"],[]],"^M",["^N",[["^13","^14","^15"],["^13","^14"],["^13"],[]]],"^T",["^N",[null,null,null,null]]],"^R",[["^13","^14","^15"],["^13","^14"],["^13"],[]],"^S",null,"^17",3,"^T",["^N",[null,null,null,null]],"^J",1,"^U",false,"~:methods",[["^ ","^17",3,"^U",false,"~:tag","~$blah.impl/Session"],["^ ","^17",2,"^U",false,"^19","^1:"],["^ ","^17",1,"^U",false,"^19","^1:"],["^ ","^17",0,"^U",false,"^19","^1:"]],"^I",67,"^K",67,"^X",3,"^Y",true,"^M",["^N",[["^13","^14","^15"],["^13","^14"],["^13"],[]]],"^Q","Initiates a blah session.\n   \n   A blah session is a core.async ReadPort that is composed of, and provides access to, an AudioContext.\n   \n   Being a ReadPort, it is consumed like any other core.async channel.\n   \n   The buffer size of the channel is determined by the AudioContext's sample rate. The signature for this\n   function is identical to core.async/chan expect an input is accepted in place of buf-or-n. A nil input\n   can be supplied in order to leverage the default audio input.\n   \n   Can be given an optional transducer to process incoming audio data, and an optional exception-handler.\n   If an exception occurs during transformation exception-handler will be called with the error, and any\n   non-nil return value will be placed in the channel.\n   \n   If no transducer is given, a default will be provided via [[blah.transforms/samples->frames]]. This transform\n   will return streamed data as a sequence of partitioned sample frames - i.e:\n\n   ```clojure\n   ((input-channel-1-sample-1\n     input-channel-2-sample-1)\n   \n    (input-channel-1-sample-2\n     input-channel-2-sample-2))\n   ```\n   \n   The channels raw data format is a js array containing Float32 array for each audio input channel:\n   \n   ```clojure\n   (defn samples->frames\n     [message] ;;; message = #js [floats-for-input-channel-1, floats-for-input-channel-2, ..., floats-for-input-channel-n]\n     (process-message))\n   ```"],"~$request-permission",["^ ","^F",null,"^G",["^ ","^H","/Users/brian/projects/blah/src/blah/core.cljs","^I",118,"^J",7,"^K",118,"^L",25,"^M",["^N",["^O",["^N",[[]]]]],"^Q","A utility for preemptively asking for access to the microphone.\n   \n   Returns a channel that will contain true or false based on the user's response.\n   \n   ```clojure\n   (go\n     (if (<! (request-permission))\n       (do-mic-jams)\n       (uh-oh-no-mic-access)))\n   ```"],"^5","^A","^H","/Users/brian/projects/blah/src/blah/core.cljs","^L",25,"^R",["^N",[[]]],"^S",null,"^T",["^N",[null,null]],"^J",1,"^U",false,"^I",118,"^V","^[","^K",118,"^X",0,"^Y",true,"^M",["^N",["^O",["^N",[[]]]]],"^Q","A utility for preemptively asking for access to the microphone.\n   \n   Returns a channel that will contain true or false based on the user's response.\n   \n   ```clojure\n   (go\n     (if (<! (request-permission))\n       (do-mic-jams)\n       (uh-oh-no-mic-access)))\n   ```"]],"~:cljs.spec/registry-ref",[["^>",["^N",["~$cljs.spec.alpha/fspec","~:args",["^N",["~$cljs.spec.alpha/cat","~:close-ch",["^N",["~$cljs.spec.alpha/?","~:blah.spec/write-port"]]]],"~:ret","~:blah.spec/read-port"]]],["^?",["^N",["^1=","^1>",["^N",["~$cljs.spec.alpha/alt","~:null",["^N",["^1?"]],"~:unary",["^N",["^1?","~:input",["^N",["~$cljs.spec.alpha/nilable","~:blah.spec/input"]]]],"~:binary",["^N",["^1?","^1H",["^N",["^1I","^1J"]],"~:xform","~$cljs.core/any?"]],"~:all",["^N",["^1?","^1H",["^N",["^1I","^1J"]],"^1L","^1M","~:ex-handler","~$cljs.core/fn?"]]]],"^1C","~:blah.spec/session"]]],["^@",["^N",["^1=","^1>",["^N",["^1?","~:session","^1Q"]],"^1C","~:blah.spec/audio-context"]]],["^A",["^N",["^1=","^1>",["^N",["^1?"]],"^1C","^1D"]]],["^B",["^N",["^1=","^1>",["^N",["^1?","~:fn-1","~:blah.spec/query-input-handler"]],"^1C","^1M"]]]],"~:require-macros",["^ ","~$s","^<","^<","^<"],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["^1>","^1L","^1K","^>","^1C","^1S","^1E","^1D","^?","^1@","^1?","^1=","^1I","^@","^1N","^1U","^1O","^1P","^1J","^1F","^1Q","^1G","^1H","^1B","^A","^1M","^B","^1T","^1R","^1A"]],"~:order",["^B","^1=","^1>","^1?","^1T","^1U","^1C","^1M","^>","^1@","^1A","^1B","^1D","^@","^1R","^1Q","^1S","^?","^1E","^1F","^1G","^1H","^1I","^1J","^1K","^1L","^1N","^1O","^1P","^A"]],"^Q","Work with audio inputs the Clojure(Script) way.\n   \n   blah aims to be a simple utility for gathering audio input\n   as a stream of data.\n   \n   blah's main purpose is to produce a cljs.core.async channel\n   of audio data (presumably from a user's microphone)."]